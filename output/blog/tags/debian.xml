<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Posts about Debian</title><link>https://chriswarrick.com/</link><atom:link href="https://chriswarrick.com/blog/tags/debian.xml" rel="self" type="application/rss+xml" /><description>A rarely updated blog, mostly about programming.</description><lastBuildDate>Fri, 30 Jan 2015 15:00:00 GMT</lastBuildDate><generator>https://github.com/Kwpolska/YetAnotherBlogGenerator</generator><item><title>systemd is awesome.</title><dc:creator>Chris Warrick</dc:creator><link>https://chriswarrick.com/blog/2015/01/30/systemd-is-awesome/</link><pubDate>Fri, 30 Jan 2015 15:00:00 GMT</pubDate><guid>https://chriswarrick.com/blog/2015/01/30/systemd-is-awesome/</guid><description>
I recently switched distros on my server, from Debian to Fedora, to use
systemd and keep it in line with my home Arch Linux system (which was
not reinstalled since 2010, by the way!)  Why is systemd so awesome?  Read
on to find out.
</description><content:encoded><![CDATA[
<p>I recently switched distros on my server, from Debian to Fedora, to use
<code class="docutils literal">systemd</code> and keep it in line with my home Arch Linux system (which was
not reinstalled since 2010, by the way!)  Why is systemd so awesome?  Read
on to find out.</p>



<p><em>(I changed the hardware for my home system along the way.  And just copied
everything over with ``dd``.  That’s Linux at its finest.)</em></p>
<section id="user-friendly">
<h1>User friendly</h1>
<p>The most important thing in systemd is its user friendliness.  systemd offers
the <code class="docutils literal">systemctl</code> tool, which can be used to control all the services.  You
can see what exactly is going on: what is running, what failed to start,
and you can also see why if you ask <code class="docutils literal">systemctl status $SERVICE</code>.</p>
</section>
<section id="services">
<h1>Services</h1>
<section id="writing-services-is-fun">
<h2>Writing services is fun</h2>
<p>If you want your own services, you just need to write some simple INI files.  No
need for bash, distro-specific frameworks and whatnot.  If I have a functioning
service written on Arch, I can just copy the file over to Fedora and blindly
enable it — assuming I have the executables installed, it’s guaranteed to work.</p>
<p>And the units are tiny:</p>
<pre class="literal-block">fedora$ wc -l /usr/lib/systemd/system/nginx.service
15 /usr/lib/systemd/system/nginx.service
debian$ wc -l /etc/init.d/nginx
101 /etc/init.d/nginx</pre>
<p>And you can write a bare-minimum systemd daemon in less than that – not so easy
with <code class="docutils literal">sysvinit</code> (writing everything on one line doesn’t count!)</p>
</section>
<section id="managing-personal-services">
<h2>Managing personal services</h2>
<p>systemd also features user-specific services.  You can run any service as your
user.  I use this to run <a class="reference external" href="https://chriswarrick.com/kwbot/">KwBot</a>, which was previously under control of
<code class="docutils literal">supervisord</code> — that’s one less dependency to care about!</p>
</section>
<section id="runlevels-do-not-exist">
<h2>Runlevels do not exist</h2>
<p>systemd does away with the standard convention of runlevels.  They are replaced
by human-friendly <em>targets</em>.  Each unit defines its target: most use
<code class="docutils literal"><span class="pre">multi-user.target</span></code>.  It is much easier to manage.</p>
</section>
<section id="no-symlink-mess">
<h2>No symlink mess</h2>
<p>Just like old sysvinit-esque systems, systemd uses symlinks to manage
enabled/disabled services.  There is just one difference: you get just <strong>one</strong>
symlink in the appropriate <code class="docutils literal">.wants</code> directory.  You do not have to look into
all the different runlevels.  <code class="docutils literal">graphical.target</code> depends on
<code class="docutils literal"><span class="pre">multi-user.target</span></code>, which in turn depends on <code class="docutils literal">basic.target</code>, which depends
on a few more targets required to get the system up and running.</p>
</section>
<section id="units-can-depend-on-each-other">
<h2>Units can depend on each other</h2>
<p>Do you have some units that require the network to be up?  Set it to be run
after and require <code class="docutils literal">network.target</code> and call it a day.</p>
</section>
</section>
<section id="the-journal">
<h1>The Journal</h1>
<p>If I want to know what is going on in my system, I can just ask <code class="docutils literal">journalctl</code>
to show me the most recent messages.  I don’t need to read a thousand different
log files — most things appear in the journal.  Sure, some things aren’t there
(yet), but what I <em>can</em> see is very useful.</p>
</section>
<section id="did-i-really-change-my-distro-for-all-that">
<h1>Did I really change my distro for all that?</h1>
<p>Yes.  I got too annoyed with Debian’s idiocy.  Also, DigitalOcean doesn’t
<em>really</em> support Debian testing, and I cannot survive with outdated software.
I feel much better and, more importantly, <strong>safer</strong> with Fedora.</p>
<p>(also, the “Veteran Unix Admins” of Devuan are a bunch of idiots.)</p>
</section>
]]></content:encoded><category>Linux</category><category>Arch Linux</category><category>Debian</category><category>Fedora</category><category>Linux</category><category>systemd</category></item></channel></rss>