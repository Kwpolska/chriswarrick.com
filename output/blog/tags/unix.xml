<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="/assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Chris Warrick (Posts about Unix)</title><link>https://chriswarrick.com/</link><description></description><atom:link href="https://chriswarrick.com/blog/tags/unix.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Thu, 31 Dec 2020 22:44:48 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Spawning subprocesses smartly and securely</title><link>https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/</link><dc:creator>Chris Warrick</dc:creator><description>&lt;div&gt;&lt;p&gt;As part of your code, you may be inclined to call a command to do
something. But is it always a good idea? How to do it safely? What happens
behind the scenes?&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;This article is written from a general perspective, with a Unix/C bias and a
very slight Python bias. The problems mentioned apply to all languages in most
environments, including Windows.&lt;/p&gt;
&lt;div class="contents right-toc topic" id="contents"&gt;
&lt;p class="topic-title"&gt;Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#use-the-right-tool-for-the-job" id="id9"&gt;Use the right tool for the job&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#dont-spawn-subprocesses-if-theres-an-alternative" id="id10"&gt;Don’t spawn subprocesses if there’s an alternative&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#security-considerations-shells-spaces-and-command-injection" id="id11"&gt;Security considerations: shells, spaces, and command injection&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#tl-dr-how-to-do-this-properly-in-your-language-of-choice" id="id12"&gt;TL;DR: How to do this properly in your language of choice&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#the-part-where-i-pretend-i-know-something-about-windows" id="id13"&gt;The part where I pretend I know something about Windows&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="use-the-right-tool-for-the-job"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#id9"&gt;Use the right tool for the job&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;By calling another process, you introduce a third-party dependency.
That dependency isn’t controlled by your code, and your code becomes more fragile.
The problems include:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;the program is not installed, or even available, for the user’s OS of choice&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;the program is not in the &lt;code class="docutils literal"&gt;$PATH&lt;/code&gt; your process gets&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;the hard-coded path is not correct on the end user’s system&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;the program is in a different version (eg. GNU vs. BSD, updates/patches),
which means different option names or other behaviors&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;the program’s output is not what you expected due to user config (including
locale)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;error reporting is based on numeric exit codes, and the meaning of those
differs between programs (&lt;em&gt;if&lt;/em&gt; they have meaning besides 0/1 in the first
place)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;On the other hand, if your code uses a lot of subprocesses, perhaps you should
stay with Bash. You can do the harder parts with Python, Ruby, or some other
language by calling them from within your Bash script.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="dont-spawn-subprocesses-if-theres-an-alternative"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#id10"&gt;Don’t spawn subprocesses if there’s an alternative&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Spawning a subprocess always incurs a (minor) &lt;a class="footnote-reference brackets" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#id5" id="id1"&gt;1&lt;/a&gt; performance hit minor
compared to the alternatives. With that in mind, and the resiliency issues
listed above, you should always try to find an alternative for the
external command.&lt;/p&gt;
&lt;p&gt;The simplest ones are the basic Unix utilities. Replace &lt;code class="docutils literal"&gt;grep&lt;/code&gt;, &lt;code class="docutils literal"&gt;sed&lt;/code&gt; and
&lt;code class="docutils literal"&gt;awk&lt;/code&gt; with string operations and regular expressions. Filesystem utilities
will have equivalents — for Python, in &lt;code class="docutils literal"&gt;os&lt;/code&gt; or &lt;code class="docutils literal"&gt;shutil&lt;/code&gt;. Your language of
choice can also handle things like networking (don’t call &lt;code class="docutils literal"&gt;curl&lt;/code&gt;), file
compression, working with date/time…&lt;/p&gt;
&lt;p&gt;Similarly, you should check if there are packages available that already do
what you want — library bindings or re-implementations. And if there isn’t,
perhaps you could help the world by writing one of those and sharing it?&lt;/p&gt;
&lt;p&gt;One more important thing: if the program uses the same language as your code,
then you should try to import the code and run it from the same process instead
of spawning a process, if this is feasible.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="security-considerations-shells-spaces-and-command-injection"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#id11"&gt;Security considerations: shells, spaces, and command injection&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We come to the most important part of this article: how to spawn subprocesses
without compromising your system. When you spawn a subprocess on a typical Unix
system,  &lt;code class="docutils literal"&gt;fork()&lt;/code&gt; is called, and your process is copied. Many modern Unix
systems have a copy-on-write implementation of that syscall, meaning that the
operation does not result in copying all the memory of the host process over.
Forking is (almost) immediately followed by calling &lt;code class="docutils literal"&gt;execve()&lt;/code&gt; (or a helper
function from the exec family) &lt;a class="footnote-reference brackets" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#id6" id="id2"&gt;2&lt;/a&gt; in the child process — that function
&lt;em&gt;transforms the calling process into a new process&lt;/em&gt; &lt;a class="footnote-reference brackets" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#id7" id="id3"&gt;3&lt;/a&gt;. This technique is
called &lt;em&gt;fork-exec&lt;/em&gt; and is the typical way to spawn a new process on Unix. &lt;a class="footnote-reference brackets" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#id8" id="id4"&gt;4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;There are two ways to access this API, from the C perspective:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;directly, by calling &lt;code class="docutils literal"&gt;fork()&lt;/code&gt; and &lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;exec*()&lt;/span&gt;&lt;/code&gt; (or &lt;code class="docutils literal"&gt;posix_spawn()&lt;/code&gt;), and providing an array of
arguments passed to the process, or&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;through the shell (&lt;code class="docutils literal"&gt;sh&lt;/code&gt;), usually by calling &lt;code class="docutils literal"&gt;system()&lt;/code&gt;. As Linux’s
manpage for &lt;code class="docutils literal"&gt;system(3)&lt;/code&gt; puts it,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;code class="docutils literal"&gt;system()&lt;/code&gt; library function uses &lt;code class="docutils literal"&gt;fork(2)&lt;/code&gt; to create a child process that executes the shell command specified in command using &lt;code class="docutils literal"&gt;execl(3)&lt;/code&gt; as follows:&lt;/p&gt;
&lt;pre class="code c"&gt;&lt;a name="rest_code_1fd0327ef44d48fab2cc5bd0b4a63913-1"&gt;&lt;/a&gt;&lt;span class="n"&gt;execl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"/bin/sh"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"sh"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"-c"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you go through the shell, you pass one string argument, whereas &lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;exec*()&lt;/span&gt;&lt;/code&gt; demands you to specify arguments separately. Let’s write a sample program to print all the arguments it receives. I’ll do it in Python to get a more readable output.&lt;/p&gt;
&lt;pre class="code python"&gt;&lt;a name="rest_code_e2162abc2be14642ac606a5fe96aec60-1"&gt;&lt;/a&gt;&lt;span class="ch"&gt;#!/usr/bin/env python3&lt;/span&gt;
&lt;a name="rest_code_e2162abc2be14642ac606a5fe96aec60-2"&gt;&lt;/a&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;a name="rest_code_e2162abc2be14642ac606a5fe96aec60-3"&gt;&lt;/a&gt;&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;Let’s see what appears:&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-1"&gt;&lt;/a&gt;$ ./argv.py foo bar
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-2"&gt;&lt;/a&gt;['./argv.py', 'foo', 'bar']
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-3"&gt;&lt;/a&gt;$ ./argv.py 'foo bar'
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-4"&gt;&lt;/a&gt;['./argv.py', 'foo bar']
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-5"&gt;&lt;/a&gt;$ ./argv.py foo\ bar baz
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-6"&gt;&lt;/a&gt;['./argv.py', 'foo bar', 'baz']
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-7"&gt;&lt;/a&gt;
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-8"&gt;&lt;/a&gt;$ ./argv.py $(date)
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-9"&gt;&lt;/a&gt;['./argv.py', 'Sat', 'Sep', '2', '16:54:52', 'CEST', '2017']
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-10"&gt;&lt;/a&gt;$ ./argv.py "$(date)"
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-11"&gt;&lt;/a&gt;['./argv.py', 'Sat Sep  2 16:54:52 CEST 2017']
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-12"&gt;&lt;/a&gt;
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-13"&gt;&lt;/a&gt;$ ./argv.py /usr/*
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-14"&gt;&lt;/a&gt;['./argv.py', '/usr/X11', '/usr/X11R6', '/usr/bin', '/usr/include', '/usr/lib', '/usr/libexec', '/usr/local', '/usr/sbin', '/usr/share', '/usr/standalone']
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-15"&gt;&lt;/a&gt;$ ./argv.py "/usr/*"
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-16"&gt;&lt;/a&gt;['./argv.py', '/usr/*']
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-17"&gt;&lt;/a&gt;
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-18"&gt;&lt;/a&gt;$ ./argv.py $EDITOR
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-19"&gt;&lt;/a&gt;['./argv.py', 'nvim']
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-20"&gt;&lt;/a&gt;
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-21"&gt;&lt;/a&gt;$ $PWD/argv.py foo bar
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-22"&gt;&lt;/a&gt;['/Users/kwpolska/Desktop/blog/subprocess/argv.py', 'foo', 'bar']
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-23"&gt;&lt;/a&gt;$ ./argv.py a{b,c}d
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-24"&gt;&lt;/a&gt;['./argv.py', 'abd', 'acd']
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-25"&gt;&lt;/a&gt;
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-26"&gt;&lt;/a&gt;$ python argv.py foo bar | cat
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-27"&gt;&lt;/a&gt;['argv.py', 'foo', 'bar']
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-28"&gt;&lt;/a&gt;$ python argv.py foo bar &amp;gt; foo.txt
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-29"&gt;&lt;/a&gt;$ cat foo.txt
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-30"&gt;&lt;/a&gt;['argv.py', 'foo', 'bar']
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-31"&gt;&lt;/a&gt;
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-32"&gt;&lt;/a&gt;$ ./argv.py foo; ls /usr
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-33"&gt;&lt;/a&gt;['./argv.py', 'foo']
&lt;a name="rest_code_4fd7dbd99e3446f68f0a7acd2932a1ea-34"&gt;&lt;/a&gt;X11@        X11R6@      bin/        include/    lib/        libexec/    local/      sbin/       share/      standalone/
&lt;/pre&gt;&lt;p&gt;As you can see, the following things are handled by the shell (the process is unaware of this occurring):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;quotes and escapes&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;expanding expressions in braces&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;expanding variables&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;wildcards (glob, &lt;code class="docutils literal"&gt;*&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;redirections and pipes (&lt;code class="docutils literal"&gt;&amp;gt; &amp;gt;&amp;gt; |&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;command substitution (backticks or &lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;$(…)&lt;/span&gt;&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;running multiple commands on the same line (&lt;code class="docutils literal"&gt;; &amp;amp;&amp;amp; || &amp;amp;&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The list is full of potential vulnerabilities. If end users are in control of
the arguments passed, and you go through the shell, they can
&lt;strong&gt;execute arbitrary commands&lt;/strong&gt; or even &lt;strong&gt;get full shell access&lt;/strong&gt;. Even in other
cases, you’ll have to &lt;em&gt;depend on the shell’s parsing&lt;/em&gt;, which introduces an
unnecessary indirection.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tl-dr-how-to-do-this-properly-in-your-language-of-choice"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#id12"&gt;TL;DR: How to do this properly in your language of choice&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To ensure spawning subprocess is done securely, &lt;strong&gt;do not use the shell in between&lt;/strong&gt;. If you need any of the operations I listed above as part of your command — wildcards, pipes, etc. — you will need to take care of them in your code; most languages have those features built-in.&lt;/p&gt;
&lt;dl class="dl-horizontal simple"&gt;
&lt;dt&gt;In C (Unix)&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;Perform fork-exec by yourself, or use &lt;code class="docutils literal"&gt;posix_spawn()&lt;/code&gt;. This also lets you communicate with the process if you open a pipe and make it stdout of the child process. Never use &lt;code class="docutils literal"&gt;system()&lt;/code&gt;.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;In Python&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;Use the subprocess module. Always pass &lt;code class="docutils literal"&gt;shell=False&lt;/code&gt; and give it a &lt;em&gt;list&lt;/em&gt; of arguments. With asyncio, use &lt;code class="docutils literal"&gt;asyncio.create_subprocess_exec&lt;/code&gt; (and not &lt;code class="docutils literal"&gt;_shell&lt;/code&gt;), but note it takes &lt;code class="docutils literal"&gt;*args&lt;/code&gt; and not a list. Never use &lt;code class="docutils literal"&gt;os.system&lt;/code&gt; and &lt;code class="docutils literal"&gt;os.popen&lt;/code&gt;.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;In Ruby&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;Pass arrays to &lt;code class="docutils literal"&gt;IO.popen&lt;/code&gt;. Pass multiple arguments to &lt;code class="docutils literal"&gt;system()&lt;/code&gt; (&lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;system(["ls",&lt;/span&gt; &lt;span class="pre"&gt;"ls"])&lt;/span&gt;&lt;/code&gt; or &lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;system("ls",&lt;/span&gt; &lt;span class="pre"&gt;"-l")&lt;/span&gt;&lt;/code&gt;). Never use &lt;code class="docutils literal"&gt;%x{command}&lt;/code&gt; or backticks.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;In Java&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;Pass arrays to &lt;code class="docutils literal"&gt;Runtime.exec&lt;/code&gt;. Pass multiple arguments or list to &lt;code class="docutils literal"&gt;ProcessBuilder&lt;/code&gt;.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;In PHP&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;All the standard methods go through the shell. Try &lt;code class="docutils literal"&gt;escapeshellcmd()&lt;/code&gt;, &lt;code class="docutils literal"&gt;escapeshellarg()&lt;/code&gt; — or better, switch to Python. Or anything, really.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;In Go&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;&lt;code class="docutils literal"&gt;os/exec&lt;/code&gt; and &lt;code class="docutils literal"&gt;os.StartProcess&lt;/code&gt; are safe.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;In Node.js&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;Use &lt;code class="docutils literal"&gt;child_process.execFile&lt;/code&gt; or &lt;code class="docutils literal"&gt;child_process.spawn&lt;/code&gt; with &lt;code class="docutils literal"&gt;shell&lt;/code&gt; set to false.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;Elsewhere&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;You should be able to specify multiple strings (using variadic arguments,
arrays, or otherwise standard data structures of your language of choice) as
the command line. Otherwise, you might be running into something
shell-related.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class="section" id="the-part-where-i-pretend-i-know-something-about-windows"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#id13"&gt;The part where I pretend I know something about Windows&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;On Windows, argument lists are always passed to processes as strings (Python
joins them semi-intelligently if it gets a list). Redirections and variables
work in shell mode, but globs (asterisks) are always left for the called
process to handle.&lt;/p&gt;
&lt;p&gt;Some useful functions are implemented as shell built-ins — in that case, you
need to call it via the shell.&lt;/p&gt;
&lt;p&gt;Internals: There is no &lt;code class="docutils literal"&gt;fork()&lt;/code&gt; on Windows. Instead, &lt;code class="docutils literal"&gt;CreateProcess()&lt;/code&gt;,
&lt;code class="docutils literal"&gt;ShellExecute()&lt;/code&gt;, or lower-level &lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;spawn*()&lt;/span&gt;&lt;/code&gt; functions are used. &lt;code class="docutils literal"&gt;cmd.exe
/c&lt;/code&gt; is called in shell calls.&lt;/p&gt;
&lt;dl class="footnote brackets"&gt;
&lt;dt class="label" id="id5"&gt;&lt;span class="brackets"&gt;&lt;a class="fn-backref" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#id1"&gt;1&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;Unless your operating system does not implement copy-on-write forking — in that case, you might even run out of memory if you use too much of it.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class="label" id="id6"&gt;&lt;span class="brackets"&gt;&lt;a class="fn-backref" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#id2"&gt;2&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;The function that does the real work is &lt;code class="docutils literal"&gt;execve()&lt;/code&gt;, which takes an exact path, an array of arguments, and takes environment variables as input. Other variants can also perform a &lt;code class="docutils literal"&gt;$PATH&lt;/code&gt; search, take argv as variadic arguments, and inherit environment from the current process. &lt;code class="docutils literal"&gt;execl()&lt;/code&gt; does the last two.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class="label" id="id7"&gt;&lt;span class="brackets"&gt;&lt;a class="fn-backref" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#id3"&gt;3&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;Quoted from &lt;code class="docutils literal"&gt;execve(2)&lt;/code&gt; &lt;a class="reference external" href="https://www.freebsd.org/cgi/man.cgi?query=execve&amp;amp;sektion=2"&gt;man page&lt;/a&gt; from FreeBSD.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class="label" id="id8"&gt;&lt;span class="brackets"&gt;&lt;a class="fn-backref" href="https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/#id4"&gt;4&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;An alternative is &lt;code class="docutils literal"&gt;posix_spawn()&lt;/code&gt;, but it usually does fork-exec, unless your platform does not support forking.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>best practices</category><category>C</category><category>devel</category><category>guide</category><category>Linux</category><category>Python</category><category>security</category><category>subprocess</category><category>Unix</category><guid>https://chriswarrick.com/blog/2017/09/02/spawning-subprocesses-smartly-and-securely/</guid><pubDate>Sat, 02 Sep 2017 18:40:00 GMT</pubDate></item><item><title>Unix locales vs Unicode (‘ascii’ codec can’t encode character…)</title><link>https://chriswarrick.com/blog/2017/06/18/unix-locales-vs-unicode/</link><dc:creator>Chris Warrick</dc:creator><description>&lt;div&gt;&lt;p&gt;You might get unusual errors about Unicode and inability to convert
to ASCII. Programs might just crash at random. Those are often simple to fix —
all you need is correct locale configuration.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p class="lead"&gt;Has this ever happened to you?&lt;/p&gt;
&lt;pre class="code pytb"&gt;&lt;a name="rest_code_3ad7462a353f4889a86f68c322cb5858-1"&gt;&lt;/a&gt;&lt;span class="gt"&gt;Traceback (most recent call last):&lt;/span&gt;
&lt;a name="rest_code_3ad7462a353f4889a86f68c322cb5858-2"&gt;&lt;/a&gt;  File &lt;span class="nb"&gt;"aogonek.py"&lt;/span&gt;, line &lt;span class="m"&gt;1&lt;/span&gt;, in &lt;span class="n"&gt;&amp;lt;module&amp;gt;&lt;/span&gt;
&lt;a name="rest_code_3ad7462a353f4889a86f68c322cb5858-3"&gt;&lt;/a&gt;    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;u&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="se"&gt;\u0105&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a name="rest_code_3ad7462a353f4889a86f68c322cb5858-4"&gt;&lt;/a&gt;&lt;span class="gr"&gt;UnicodeEncodeError&lt;/span&gt;: &lt;span class="n"&gt;'ascii' codec can't encode character '\u0105' in position 0: ordinal not in range(128)&lt;/span&gt;
&lt;/pre&gt;&lt;pre class="code text"&gt;&lt;a name="rest_code_9a9cc11d50d84d1d9d7cb3eaa1f4dd3b-1"&gt;&lt;/a&gt;Nikola: Could not guess locale for language en, using locale C
&lt;/pre&gt;&lt;pre class="code text"&gt;&lt;a name="rest_code_63c9c7640fa2413f81f8d52c14c16a71-1"&gt;&lt;/a&gt;Input: ą
&lt;a name="rest_code_63c9c7640fa2413f81f8d52c14c16a71-2"&gt;&lt;/a&gt;Desired ascii(): '\u0105'
&lt;a name="rest_code_63c9c7640fa2413f81f8d52c14c16a71-3"&gt;&lt;/a&gt;Real ascii(): '\udcc4\udc85'
&lt;/pre&gt;&lt;pre class="code text"&gt;&lt;a name="rest_code_ad8d9cc7c64843b393cd9409d8e4ae6b-1"&gt;&lt;/a&gt;perl: warning: Setting locale failed.
&lt;a name="rest_code_ad8d9cc7c64843b393cd9409d8e4ae6b-2"&gt;&lt;/a&gt;perl: warning: Please check that your locale settings:
&lt;a name="rest_code_ad8d9cc7c64843b393cd9409d8e4ae6b-3"&gt;&lt;/a&gt;    [...]
&lt;a name="rest_code_ad8d9cc7c64843b393cd9409d8e4ae6b-4"&gt;&lt;/a&gt;    are supported and installed on your system.
&lt;a name="rest_code_ad8d9cc7c64843b393cd9409d8e4ae6b-5"&gt;&lt;/a&gt;perl: warning: Falling back to the standard locale ("C").
&lt;/pre&gt;&lt;p class="lead"&gt;All those errors have the same root cause: incorrect locale configuration.
To fix them all, you need to generate the missing locales and set them.&lt;/p&gt;
&lt;div class="section" id="check-currently-used-locale"&gt;
&lt;h2&gt;Check currently used locale&lt;/h2&gt;
&lt;p&gt;The &lt;code class="docutils literal"&gt;locale&lt;/code&gt; command (without arguments) should tell you which locales you’re
currently using.  (The list might be shorter on your end)&lt;/p&gt;
&lt;pre class="code sh"&gt;&lt;a name="rest_code_d82a3d907beb4e1c9cb34d05378af0a9-1"&gt;&lt;/a&gt;$ locale
&lt;a name="rest_code_d82a3d907beb4e1c9cb34d05378af0a9-2"&gt;&lt;/a&gt;&lt;span class="nv"&gt;LANG&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"en_US.UTF-8"&lt;/span&gt;
&lt;a name="rest_code_d82a3d907beb4e1c9cb34d05378af0a9-3"&gt;&lt;/a&gt;&lt;span class="nv"&gt;LC_CTYPE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"en_US.UTF-8"&lt;/span&gt;
&lt;a name="rest_code_d82a3d907beb4e1c9cb34d05378af0a9-4"&gt;&lt;/a&gt;&lt;span class="nv"&gt;LC_NUMERIC&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"en_US.UTF-8"&lt;/span&gt;
&lt;a name="rest_code_d82a3d907beb4e1c9cb34d05378af0a9-5"&gt;&lt;/a&gt;&lt;span class="nv"&gt;LC_TIME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"en_US.UTF-8"&lt;/span&gt;
&lt;a name="rest_code_d82a3d907beb4e1c9cb34d05378af0a9-6"&gt;&lt;/a&gt;&lt;span class="nv"&gt;LC_COLLATE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"en_US.UTF-8"&lt;/span&gt;
&lt;a name="rest_code_d82a3d907beb4e1c9cb34d05378af0a9-7"&gt;&lt;/a&gt;&lt;span class="nv"&gt;LC_MONETARY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"en_US.UTF-8"&lt;/span&gt;
&lt;a name="rest_code_d82a3d907beb4e1c9cb34d05378af0a9-8"&gt;&lt;/a&gt;&lt;span class="nv"&gt;LC_MESSAGES&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"en_US.UTF-8"&lt;/span&gt;
&lt;a name="rest_code_d82a3d907beb4e1c9cb34d05378af0a9-9"&gt;&lt;/a&gt;&lt;span class="nv"&gt;LC_PAPER&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"en_US.UTF-8"&lt;/span&gt;
&lt;a name="rest_code_d82a3d907beb4e1c9cb34d05378af0a9-10"&gt;&lt;/a&gt;&lt;span class="nv"&gt;LC_NAME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"en_US.UTF-8"&lt;/span&gt;
&lt;a name="rest_code_d82a3d907beb4e1c9cb34d05378af0a9-11"&gt;&lt;/a&gt;&lt;span class="nv"&gt;LC_ADDRESS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"en_US.UTF-8"&lt;/span&gt;
&lt;a name="rest_code_d82a3d907beb4e1c9cb34d05378af0a9-12"&gt;&lt;/a&gt;&lt;span class="nv"&gt;LC_TELEPHONE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"en_US.UTF-8"&lt;/span&gt;
&lt;a name="rest_code_d82a3d907beb4e1c9cb34d05378af0a9-13"&gt;&lt;/a&gt;&lt;span class="nv"&gt;LC_MEASUREMENT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"en_US.UTF-8"&lt;/span&gt;
&lt;a name="rest_code_d82a3d907beb4e1c9cb34d05378af0a9-14"&gt;&lt;/a&gt;&lt;span class="nv"&gt;LC_IDENTIFICATION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"en_US.UTF-8"&lt;/span&gt;
&lt;a name="rest_code_d82a3d907beb4e1c9cb34d05378af0a9-15"&gt;&lt;/a&gt;&lt;span class="nv"&gt;LC_ALL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;If any of those is set to &lt;code class="docutils literal"&gt;C&lt;/code&gt; or &lt;code class="docutils literal"&gt;POSIX&lt;/code&gt;, has a different encoding than
&lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;UTF-8&lt;/span&gt;&lt;/code&gt; (sometimes spelled &lt;code class="docutils literal"&gt;utf8&lt;/code&gt;) is empty (with the exception of
&lt;code class="docutils literal"&gt;LC_ALL&lt;/code&gt;), or if you see any errors, you need to reconfigure your locale.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="check-locale-availability-and-install-missing-locales"&gt;
&lt;h2&gt;Check locale availability and install missing locales&lt;/h2&gt;
&lt;p&gt;The first thing you need to do is check locale availability. To do this, run
&lt;code class="docutils literal"&gt;locale &lt;span class="pre"&gt;-a&lt;/span&gt;&lt;/code&gt;. This will produce a list of all installed locales.  You can use
&lt;code class="docutils literal"&gt;grep&lt;/code&gt; to get a more reasonable list.&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_1fd5d3863a314a39a4fb36a1767b8828-1"&gt;&lt;/a&gt;$ locale -a | grep -i utf
&lt;a name="rest_code_1fd5d3863a314a39a4fb36a1767b8828-2"&gt;&lt;/a&gt;&amp;lt;lists all UTF-8 locales&amp;gt;
&lt;a name="rest_code_1fd5d3863a314a39a4fb36a1767b8828-3"&gt;&lt;/a&gt;$ locale -a | grep -i utf | grep -i en_US
&lt;a name="rest_code_1fd5d3863a314a39a4fb36a1767b8828-4"&gt;&lt;/a&gt;en_US.UTF-8
&lt;/pre&gt;&lt;p&gt;The best locale to use is the one for your language, with the UTF-8 encoding.
The locale will be used by some console apps for output. I’m going to use
&lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;en_US.UTF-8&lt;/span&gt;&lt;/code&gt; in this guide.&lt;/p&gt;
&lt;p&gt;If you can’t see any UTF-8 locales, or no appropriate locale setting for your
language of choice, you might need to generate those. The required actions
depend on your distro/OS.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Debian, Ubuntu, and derivatives: install &lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;language-pack-en-base&lt;/span&gt;&lt;/code&gt;, run &lt;code class="docutils literal"&gt;sudo &lt;span class="pre"&gt;dpkg-reconfigure&lt;/span&gt; locales&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RHEL, CentOS, Fedora: install &lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;glibc-langpack-en&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Arch Linux: uncomment relevant entries in &lt;code class="docutils literal"&gt;/etc/locale.gen&lt;/code&gt; and run &lt;code class="docutils literal"&gt;sudo &lt;span class="pre"&gt;locale-gen&lt;/span&gt;&lt;/code&gt; &lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Locale"&gt;(wiki)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For other OSes, refer to the documentation.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You need a UTF-8 locale to ensure compatibility with software. Avoid the &lt;code class="docutils literal"&gt;C&lt;/code&gt;
and &lt;code class="docutils literal"&gt;POSIX&lt;/code&gt; locales (it’s ASCII) and locales with other encodings (those
aren’t used by ~anyone these days)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="configure-system-wide"&gt;
&lt;h2&gt;Configure system-wide&lt;/h2&gt;
&lt;p&gt;On some systems, you may be able to configure locale system-wide.  Check your
system documentation for details. If your system has systemd, run&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_64aea9232bef45c19da8a33afe18ba8b-1"&gt;&lt;/a&gt;sudo localectl set-locale LANG=en_US.UTF-8
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="configure-for-a-single-user"&gt;
&lt;h2&gt;Configure for a single user&lt;/h2&gt;
&lt;p&gt;If your environment does not allow system-wide locale configuration (macOS,
shared server with generated but unconfigured locales), or if you want to
ensure it’s always configured independently of system settings.&lt;/p&gt;
&lt;p&gt;To do this, you need to edit the configuration file for your shell. If you’re
using bash, it’s &lt;code class="docutils literal"&gt;.bashrc&lt;/code&gt; (or &lt;code class="docutils literal"&gt;.bash_profile&lt;/code&gt; on macOS). For zsh users,
&lt;code class="docutils literal"&gt;.zshrc&lt;/code&gt;.  Add this line (or equivalent in your shell):&lt;/p&gt;
&lt;pre class="code sh"&gt;&lt;a name="rest_code_0d297442305846608f3bf3c58ea68fd9-1"&gt;&lt;/a&gt;&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;LANG&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;en_US.UTF-8 &lt;span class="nv"&gt;LC_ALL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;en_US.UTF-8
&lt;/pre&gt;&lt;p&gt;That should be enough. Note that those settings don’t apply to programs
not launched through a shell.&lt;/p&gt;
&lt;hr class="docutils"&gt;
&lt;p&gt;&lt;strong&gt;Python/Windows corner:&lt;/strong&gt; Python 3.7 will fix this on Unix by assuming UTF-8
if it encounters the C locale.  On Windows, Python 3.6 is using UTF-8
interactively, but not when using shell redirections to files or pipes.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;This post was brought to you by ą — U+0105 LATIN SMALL LETTER A WITH OGONEK.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>guide</category><category>locale</category><category>Python</category><category>Unicode</category><category>Unix</category><guid>https://chriswarrick.com/blog/2017/06/18/unix-locales-vs-unicode/</guid><pubDate>Sun, 18 Jun 2017 18:40:00 GMT</pubDate></item></channel></rss>